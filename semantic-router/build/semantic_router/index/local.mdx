---
sidebar_label: local
title: semantic_router.index.local
---

## LocalIndex Objects

```python
class LocalIndex(BaseIndex)
```

#### add

```python
def add(embeddings: List[List[float]],
        routes: List[str],
        utterances: List[str],
        function_schemas: Optional[List[Dict[str, Any]]] = None,
        metadata_list: List[Dict[str, Any]] = [],
        **kwargs)
```

Add embeddings to the index.

**Arguments**:

- `embeddings` (`List[List[float]]`): List of embeddings to add to the index.
- `routes` (`List[str]`): List of routes to add to the index.
- `utterances` (`List[str]`): List of utterances to add to the index.
- `function_schemas` (`Optional[List[Dict[str, Any]]]`): List of function schemas to add to the index.
- `metadata_list` (`List[Dict[str, Any]]`): List of metadata to add to the index.

#### get\_utterances

```python
def get_utterances(include_metadata: bool = False) -> List[Utterance]
```

Gets a list of route and utterance objects currently stored in the index.

**Arguments**:

- `include_metadata`: Whether to include function schemas and metadata in
the returned Utterance objects - LocalIndex doesn&#x27;t include metadata so this
parameter is ignored.

**Returns**:

`List[Utterance]`: A list of Utterance objects.

#### describe

```python
def describe() -> IndexConfig
```

Describe the index.

**Returns**:

`IndexConfig`: An IndexConfig object.

#### is\_ready

```python
def is_ready() -> bool
```

Checks if the index is ready to be used.

**Returns**:

`bool`: True if the index is ready, False otherwise.

#### query

```python
def query(
    vector: np.ndarray,
    top_k: int = 5,
    route_filter: Optional[List[str]] = None,
    sparse_vector: dict[int, float] | SparseEmbedding | None = None
) -> Tuple[np.ndarray, List[str]]
```

Search the index for the query and return top_k results.

**Arguments**:

- `vector` (`np.ndarray`): The vector to search for.
- `top_k` (`int`): The number of results to return.
- `route_filter` (`Optional[List[str]]`): The routes to filter the search by.
- `sparse_vector` (`dict[int, float] | SparseEmbedding | None`): The sparse vector to search for.

**Returns**:

`Tuple[np.ndarray, List[str]]`: A tuple containing the query vector and a list of route names.

#### aquery

```python
async def aquery(
    vector: np.ndarray,
    top_k: int = 5,
    route_filter: Optional[List[str]] = None,
    sparse_vector: dict[int, float] | SparseEmbedding | None = None
) -> Tuple[np.ndarray, List[str]]
```

Search the index for the query and return top_k results.

**Arguments**:

- `vector` (`np.ndarray`): The vector to search for.
- `top_k` (`int`): The number of results to return.
- `route_filter` (`Optional[List[str]]`): The routes to filter the search by.
- `sparse_vector` (`dict[int, float] | SparseEmbedding | None`): The sparse vector to search for.

**Returns**:

`Tuple[np.ndarray, List[str]]`: A tuple containing the query vector and a list of route names.

#### aget\_routes

```python
def aget_routes()
```

Get all routes from the index.

**Returns**:

`List[str]`: A list of routes.

#### delete

```python
def delete(route_name: str)
```

Delete all records of a specific route from the index.

**Arguments**:

- `route_name` (`str`): The name of the route to delete.

#### delete\_index

```python
def delete_index()
```

Deletes the index, effectively clearing it and setting it to None.

**Returns**:

`None`: None

